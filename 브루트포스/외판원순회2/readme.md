## 외판원 순회 2(10971)
> 브루트포스

### 풀이 
> 외판원순회2.js
> 실패한 코드 

1. 각 도시들을 시작점으로 두고 시작한다. 
2. 갈 수 있는 도시들 중에서 자기 자신이 아니고, 비용이 0이 아닌 경우에만
   - 해당 도시를 `res`배열에 넣고, 비용을 합산한 후 해당 도시를 기준으로 위 과정을 반복한다. 
   - `res`에 모든 도시를 넣었으면 마지막 도시에서 첫 도시로도 이동할 수 있는지 확인한다.
   - 이동 가능할 때 합산한 비용 + 첫도시로 가는 비용이 최솟값인지 확인한다. 
3. 최솟값을 출력한다. 

그런데 시간초과...

예상컨데 어딘가에서 무한루프가 도는건 아닐까 생각든다. 

어쨌든 1시간 좀 넘게 고민했는데, 기약없는 시간초과 판정에 결국 구글링을 했다. 

> re외판원순회2.js

1. 도시를 순회할 수 있는 모든 경우를 구한다. 
   - 도시들을 순회하는 순열을 모두 구하는 것이다. 
2. 위에서 구한 모든 경우를 돌려본다.
   - 도는 중간에 갈 수 없는 길(비용이 0)이면 break, flag = false
   - 그렇지 않은 경우에만 비용을 합산한다. 
3. 합산한 비용 중 최솟값을 구해 출력한다. 

근데 ... 메모리 초과?

도대체 어디서 메모리 초과가 나는 건지 이해되지 않았다 ㅜㅜ 

그렇게 또 시간을 들이다가, 문득 '모든 경우의 수를 배열에 넣고 시작해서 그런간가?' 싶은 생각이 들었다. 

그래서

1. 도시를 순회할 수 있는 경우를 구한다. 
2. 순회할 수 있는 경우를 구했을 떄 
   - 마지막 도시에서 순회를 시작한 도시로 갈 수 있는 경우에만 도시를 순회한다. 
   - 순회 중간에 비용이 0이면? break하고 끝낸다. 
   - 그렇지 않으면? 합산한 비용 중 최소비용을 구한다.
3. 최소 비용을 출력한다. 

이렇게 푸니까 일단 통과했다. 

모든 경우를 한 배열에 넣고, 그 다음 해당 배열을 돌릴 때보다는 메모리를 적게 쓰기 때문에 통과한 것 같다. 

그러나.. 시간복잡도가 맘에 들지 않았는데...

> rere외판원순회2.js

1. 각 도시들을 시작점으로 두고 시작한다. 
2. 도시 방문 체크할 `visit`배열을 만든다. 
3. 현재 시작하는 도시에서 갈 수 있는 도시 중
   1. 방문하지 않았고, 비용도 0보다 클 때 
   2. 일단 방문했음 체크를 해준다.
   3. '합산한 비용 +  다음 도시로 갈때 드는 비용'이 최소 비용보다 적을 때에만
      - 다음 도시를 시작점으로 위 과정을 반복한다. 
   4. 그렇지 않으면 방문하지 않은 걸로 다시 바꿔준다. 
4. 도시를 n만큼 방문했고, 다음 방문할 도시가 처음 방문했던 도시라면
   - 최소 비용을 구한다. 
5. 최소 비용을 출력한다. 

훨씬 시간이 적었다. 

메모리도 많이 쓸 필요가 없었고, 무엇보다 "현재 최소 비용"보다 이미 더 비용이 높으면 확인할 것도 없으니 시간도 훨씬 덜 들었던 거 같다. 

쓸데없는 순회를 하지 않아서 더 좋은 코드였던 것 같다. 


