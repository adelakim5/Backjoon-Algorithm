## 캐슬 디펜스 (17135)
> 브루트포스

### 풀이 
> main.js
1. 전체 적들의 개수를 구한다.
2. 궁수를 배치할 수 있는 위치들의 조합을 구한다. 
   - 궁수 3명이 한 세트다. 
3. 각 궁수 세트들을 배치했을 때 궁수들이 죽인 전체 적들의 개수를 구한다. 
   1. 원래의 격자상태를 복사한다. 
   2. 적들의 개수를 전체 개수로 초기화한다.
   3. 죽인 적들의 개수를 0으로 초기화한다.
   4. 전체 적들의 개수가 0이 될때까지 아래를 반복한다.
   5. 복사한 격자상태를 **마지막 행, 첫번째 열**부터 **첫번째 행, 마지막 열**까지 돌면서
      - 해당 값이 1, 즉 적이면 거리를 측정한다. 
      - 길이가 d이하이면 
        - 현재까지 측정했던 최소 거리보다 더 짧은지, 혹은 현재까지 잰 최소 거리와 같은데 더 왼쪽에 있는지 확인한다. 
          - 이에 부합할 때, **최소 거리**를 갱신하고, **제거할 적**의 좌표로 저장한다. 
      - 제거할 적이 존재하면 **궁수 3명이 제거할 적**으로 저장한다. 
        - 궁수 3명은 같은 적을 동시에 제거할 수 있기 때문에 중복된 적을 죽일 수도 있다. 이를 체크 해주기 위해 Set에 적을 저장하였다.
        - 이 Set에 담기는 적들은 **현재** 궁수들이 죽일 적들이다. 전체적으로 죽이는 적들이 아님!
      - 현재 궁수 3명이서 제거할 적들이 Set에 모두 담겼다면? 이 Set의 사이즈만큼 궁수들이 "한번" 공격할 수 있다. 
      - 모든 게임이 끝날 때까지 공격한 적들의 개수를 구해주어야 하므로, Set의 사이즈를 합산해주어야 한다 => 이 합산된 값이 바로 **죽인 적들의 전체 개수!** 
      - 제거된 적들의 개수만큼 전체 적들의 개수도 줄여준다.
      - 현재 가장 마지막에 있는 적들은 **이제 성으로 들어갈 것이다.** => 성으로 들어가면 더이상 공격할 수 없으므로, 가장 마지막 행에 있는 (공격하지 못한) 적들을 모두 0으로 바꿔준다. 
      - 한번 공격한 후엔 적들이 아래로 내려오므로, 현재 위치한 적들을 한칸씩 아래로 배치한다. 
4. 죽인 적들의 전체 개수중 최댓값을 구해 출력한다. 

처음엔 이렇게 풀었다.

그런데 생각해보니... 굳이 적들을 아래로 내리지 않아도 될 것 같았다. 

어차피 적들이 아래로 내려오는거면, 그 자리에서 궁수들이 위로 한칸씩 올라가는 것과 마찬가지가 아닌가?!

모든 적들을 아래로 한칸씩 옮기면, n*m정도의 시간이 소요될텐데, 궁수들을 위로 올리는게 훨씬 효율적이라고 생각이 들어 **다시 풀었다.**

> re_main.js
1. 궁수들을 배치할 수 있는 위치들의 조합을 구한다. 
2. 궁수 세트를 배치할 때마다
   1. 궁수가 위치하는 행을 n으로 초기화한다.
   2. 죽일 수 있는 적들의 개수를 0으로 초기화한다.
   3. 원래의 격자상태를 복사한다. 
   4. 궁수가 위치한 행이 0이 될때까지 
      - 각 궁수 1명당 죽일 수 있는 적을 저장한다. 
      - ※ 같은 적이 저장되었을 수도 있다. 
        - 따라서 적의 상태가 1일 때에만 죽이고, 적을 죽이면 0으로 값을 바꿔준다.
        - 현재 까지 죽인 적의 개수를 세어준다.  
      - 궁수가 위치한 행 **바로 윗행**에 위치한 적들은 이제 성으로 없어질 적들이다. 
        - 바로 윗행에 위치한 적들을 0으로 없애준다. 
      - 궁수한 위치한 행을 하나씩 줄여준다. 
   5. 위 과정을 반복한다. 
3. 죽인 적의 개수 중 최댓값을 출력한다.   

📌 느낀점
- 시간이 오래 걸린 문제였다. 
  - 도대체 내 로직의 어느 부분이 틀렸는지 이해하지 못해 시간을 많이 허비했다.
  - 알고리즘 자체는 틀리지 않았는데, 조건에 빵꾸(?)가 났었다.
    - 궁수가 n열에 있다고 생각하고서는, 너무 단순하게 n-1열에 있는 적들만 공격한다고 생각했다.
    - 그래서 다른 행들을 살피지도 않고 n-1열에 있는 적들만 공격대상으로 넣다보니 예제 6번 테스트케이스가 계속 오답이 나왔다. 

   