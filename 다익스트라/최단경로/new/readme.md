## 최단경로 (1753)

> 다익스트라

### 풀이

문제 - [최단경로](https://www.acmicpc.net/problem/1753)

1. 이차원배열이 아니라 **리스트**로 그래프를 구현한다.
   - 메모리초과 때문!
   - 각 지점마다 연결된 지점과 비용을 저장한다.
2. 최소힙을 구현한다.
   - 시간초과가 걸릴 수 있기 때문에 단순히 배열로 만들어 매번 sort 해주기보다 최소힙을 구현하는것이 좋다.
3. 최단거리 배열을 만든다.
   - 시작 지점으로부터 각 지점까지 드는 거리비용을 계산할 배열
   - 모두 `INF`로 초기화한다.
   - 시작 지점의 값만 0으로 바꾼다.
4. 다익스트라 알고리즘을 구현한다.
   1. 힙에 시작 지점과 비용을 넣고 시작한다.
      - `{weight: 거리비용, vertex: 현재지점}` 이런 방식으로 노드를 만들어 넣는다.
   2. 힙에서 노드를 하나 뺀다.
      - `currentNode = {weight: 0, vertex: 시작지점}`
   3. 최단거리 배열내 시작지점 값과 비용이 일치한지 확인한다.
      - `최단거리[vertex] === weight ?`
      - 일치하지 않으면 무시한다.
      - 일치하면 다음을 진행한다.
   4. 현재 vertex와 연결된 지점을 탐색한다.
      - `list[vertex]`를 탐색한다.
   5. 현재 vertex와 연결된 지점의 비용과 현재 거리 비용을 더한다.
      - `list[vertex]`에 어떤 지점과 얼만큼의 비용으로 연결되어있는지 저장하였으므로, **시작 지점에서 vertex를 거쳐 그 지점에 얼만큼의 비용으로 도달** 할 수 있는지 알 수 있다.
      - 최단거리 배열에서 그 지점의 값과 비교하여 **시작지점 -> vertex -> 그 지점**으로 가는 비용이 더 적으면 최단거리 배열 내 그 지점의 값을 갱신한다.
        - `최단거리 배열[그 지점] > 최단거리[vertex] + list[vertex][그 지점]` 이면 => `최단거리 배열[그 지점] = 최단거리[vertex] + list[vertex][그 지점]`
        - 이 값을 힙에 넣는다.
   6. 힙히 비워질동안 위 과정을 반복한다.
