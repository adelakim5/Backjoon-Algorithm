## 2048(Easy) (12100)
> 브루트포스

### 풀이
1. 우선 전체 블록들을 모조리 옮겨놓는다. 
   - 상: 전체 블록들을 모조리 위로 옮긴다.
   - 하: 전체 블록들을 모조리 아래로 옮긴다.
   - 좌: 전체 블록들을 모조리 왼쪽으로 옮긴다.
   - 우: 전체 블록들을 모조리 오른쪽으로 옮긴다. 

    즉, 중간에 0이 없도록 모조리 한 방향으로 옮겨주는 것이다. 일단 이렇게 옮기고 시작한다. 

2. 상, 하, 좌, 우를 돌면서 값을 합친다. 
   - 상: 현재 나보다 위에 있는 숫자와 나의 숫자가 같으면 합친다. 
     - 위에 있는 숫자를 두배 해주고, 현재 위치값을 0으로 바꾼다. 
   - 하: 현재 나보다 아래에 있는 숫자와 나의 숫자가 같으면 합친다.
     - 아래에 있는 숫자를 두배 해주고, 현재 위치값을 0으로 바꾼다. 
   - 좌: 현재 나보다 왼쪽에 있는 숫자와 나의 숫자가 같으면 합친다. 
     - 왼쪽에 있는 숫자를 두배 해주고, 현재 위치값을 0으로 바꾼다. 
   - 우: 현재 나보다 오른쪽에 있는 숫자와 나의 숫자가 같으면 합친다. 
     - 오른쪽에 있는 숫자를 두배 해주고, 현재 위치값을 0으로 바꾼다. 

3. 다시 블록을 옮긴다. 

    ​2번을 거치면서 중간에 0이 생겼을 수 있다. 1번처럼 중간에 0이 없도록 모조리 한 방향으로 옮겨준다. 

> #### 🤷‍♀️ 왜 이렇게 3단계로 나눠 옮겨?
>👉 한번 합쳐진 애들은 다시 합쳐질 수 없다.
>따라서 합쳐질 수 있는 숫자들을 그 자리에서 한번만 합쳐주는 것이다. 합칠 수 있는 수들을 모두 합치고 난 후 블록을 제대로 세팅하는 것이다. 

4. 위 과정을 상,하,좌,우로 5번까지 돌린다.
​   
    가장 큰 블록을 찾아 출력한다. 

​

#### 🤦‍♀️나의 시행착오

1. 일단 위처럼 3단계로 나눠 풀어야 겠다는 생각을 못했었다. 
   - 나는 한번에 옮기면서 값을 합치는 방식으로만 생각이 매몰되어있었다. 그래서 한번 합쳐진 수는 다음번에 합쳐질 수 없도록 기억해야하는데, 이 부분에서 생각이 잘 돌아가지 않아 헤맸다.
2. 구현을 잘 못했다.
   - ...그래서 계산이 엉망진창.. ㅠㅠ
3. 재귀함수를 사용하지 않았었다. 
    - 처음에는 상,하,좌,우로 5번 돌릴 수 있는 모든 조합을 뽑아냈다. 
    - Set을 사용해서 모든 조합을 뽑아낸 후, 해당 조합을 모두 돌려가면서 max블록을 찾았다. 물론 맞긴 했는데 시간 복잡도가 커졌다. 