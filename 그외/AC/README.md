## AC (5430)
> 덱

※ AC_Deque.js 가 통과한 코드

### 풀이
1. 함수에 있는 D의 개수를 센다.
   - D가 N보다 크면? error 출력
   - D와 N이 같으면? 빈배열 출력
   - D가 N보다 작으면? 2번을 진행한다.

2. 문자열로 들어온 배열을 진짜 배열로 만든다. 
   - `[],`와 같은 애들을 기준으로 split 한다. 그러면 인덱스 0과 length-1인 부분이 공백 문자열이 들어간다. 
   - 1부터 length-1 전까지 배열을 자른다. => 공백 문자열 없애기 위함
   - 배열에 담긴 숫자들을 **덱**에 넣는다. 

3. 덱을 구현한다.

4. 덱에 담긴 숫자들을 가지고 함수를 진행한다. 
   - 현재 숫자들이 정순으로 되어있는데 "R"함수를 만나면 **역순**이 되니까
     - 현재 숫자들이 "역순" 이라는 것을 기억한다.
     - "D" 함수를 만나면 숫자를 **뒤에서부터** 없앤다 => `pop`한다. 
   - 현재 숫자들이 역순으로 되어있는데 "R"함수를 만나면 **정순**이 되니까
     - 현재 숫자들이 "정순" 이라는 것을 기억한다.
     - "D" 함수를 만나면 숫자를 **앞에서부터** 없앤다 => `shift`한다.
   - 현재 숫자들이 **어떤 순으로** 되어있는지에 따라 역순/정순 배열을 ","와 함께 join하고 "[]"로 감싸 return한다. => 이 값이 1번의 세번째 조건에 해당하는 답이 된다.

#### 📌나의 시행착오
- 문자열인지 배열인지 통일시켜주어야 한다.
  - 너무 당연한 소린데(;;) 나는 코드를 짜다가 스스로 헷갈렸는지 이거 때문에 런타임에러가 몇번 났다.
- 배열안에 있는 숫자는 **여러자리 숫자**일 수 있다.
  - 예제엔 10 미만의 한자리 숫자들만 있지만, 실제 채점땐 두자리 숫자도 올 수 있다. 이를 유의한다. 
- R이 언제언제 오느냐가 중요하다.
  - (약간 바보같지만..) R이 짝수번이면 어차피 그대로고, 홀수번이면 역순이니까 이에 따라 역순 OR 그대로 놓고 D만 신경쓰면 되겠네? 라고 아주 큰 오산을 했다. 
  - 한번 역순으로 뒤집고 D를 몇번 시행한 다음 다시 R을 만나 정순으로 둔 후 D를 수행하면 ... 당연히 없어지는 숫자들이 각각 다르므로 답도 다르게 나온다.
- 덱으로 풀어야 메모리초과, 시간초과 모두 잡을 수 있었다.
  - 사실 나는 "큰 상관 없겠지..." 하면서 배열을 앞뒤로 `slice`하는 식으로 구현했었다. 계속된 메모리초과 ㅜㅜ