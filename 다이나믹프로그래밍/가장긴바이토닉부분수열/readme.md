## 가장 긴 바이토닉 부분수열(11054)

> 다이나믹 프로그래밍

### 풀이

1. 증가수열, 감소수열을 구하기 위한 dp 배열을 각각 둔다.
   1. 증가수열
      - nums[index]가 마지막 index가 되는 증가수열을 만든다.
      - 0부터 n까지 돌면서 계산한다.
   2. 감소수열
      - nums[index]가 첫번째 index가 되는 감소수열을 만든다.
      - n-1부터 0까지 돌면서 계산한다.
2. 증가수열, 감소수열의 각 인덱스를 합한 값 중 가장 큰 값을 고른다.
   - 단, 같은 숫자가 반복되기 때문에 -1 해준다.
   - 해당 최댓값을 출력한다.

#### ✍ 새로운 팁

- 반복문 하나로 해결한다.
  - 사실 나는 up, down으로 dp배열을 각각 만들고, 각 배열을 채워넣기 위한 함수를 따로 만들었다.
  - 그러나 한 반복문 내에서 0~n, n-1~0으로 계산하는 것이 시간복잡도, 공간복잡도 모두 훨씬 효율적이었다.
  - 증가수열의 경우, 나보다 작은 값을 찾기 위해 내 이전에 있는 숫자들을 확인해야 하고, 감소수열은 나보다 작은 값을 찾기 위해 내 이후에 있는 숫자들을 확인해야 한다.
  - 이 부분만 잘 고려해서 계산하면 된다.

이러나 저러나 dp는 점화식 세우는게 참 어렵다 ㅜㅜ
