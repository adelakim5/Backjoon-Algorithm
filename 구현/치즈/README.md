## 치즈 (2636)
> 구현

### 풀이
1. 녹을 치즈들을 골라낸다. 
   1. 이를 위해 visit 배열을 만들었다. 초기 visit은 모두 -1로 채워진 상태이다.
   2. 이 visit의 (0,0)부터 dfs로 탐색한다.
      - 만약 인접한 부분이 치즈이면? 해당 visit 값을 1로 바꾸고, 녹일 치즈 후보(nq 배열)에 저장해놓는다. 
        - 바로 바깥 공기와 맞닿은 가장 바깥 부분의 치즈이기 때문
      - 인접한 부분이 치즈가 아니면? 해당 visit 값을 0으로 바꾼다. 
  
    이 과정을 현재 자신이 **순수 바깥 공기일 떄**만 수행한다. 

2. 치즈가 모두 녹으면 반복을 종료한다.
   - 치즈가 모두 녹지 않았다면? 현재 남은 치즈 양을 구한다. 

    치즈가 모두 녹았을 때, 녹은 시간과 직전에 저장했던 남은 치즈양을 출력한다. 

#### 🤦‍♀️ 나의 시행착오
1. 치즈 공기가 1개인 경우로만 생각했던거...
2. 바깥공기와 치즈공기를 구분하기 위해, 치즈공기를 dfs로 탐색해나갔다. 

    누가봐도 치즈공기인 지점 하나를 잡고 깊이 탐색을 하다가 너무 자연스럽게 치즈 바깥으로 나가버리면 그건 치즈공기가 아니라고 생각하고 전부 삭제!

3. 녹을 치즈인지 아닌지를 bfs로 탐색했다. 

   치즈 공기가 아닌 바깥 공기랑 인접한거면 녹을 치즈!

    그러다보니 시간복잡도가 매우 커졌다...
 
3. 치즈가 다 녹기 한시간 전의 치즈 양을 저장하기 한 배열을 만들어놓았다. 시간별로 저장했다 ... 메모리 초과 ㅜㅜ 그냥 정수형 변수에 넣자

조금 더 자세한 설명 ... [[코딩테스트] 백준 - 치즈 (2636)](https://blog.naver.com/diddnjs02/222142535830)

