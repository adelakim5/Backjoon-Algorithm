## DSLR

> 백준 9019번
> BFS

## 풀이

BFS 활용해서 푼다.

시간 초과없이 BFS를 이용하여 풀 수 있는지가 관건인 문제이다. 특히, L, R을 구현할 때 시간 단축하는 것이 중요하다.

1. visited, from, how 배열을 만든다.

- visited: 방문 체크
- from: `from[i]`는 i를 만든 수를 저장
- how: `how[i]`는 i를 어떤 명령어로 만들었는지 저장

2. L, R 으로 만들어지는 수를 계산한다.

- L은 왼쪽으로 한 칸씩 이동하는 것

```
ex. 9991
-> 결과: 9919가 되어야 함

1. 9991 % 1000 = 991 (첫째 자리 수를 뺐을 때 나오는 수)
2. 991 * 10 = 9910 (1번의 수에 10을 곱하여 천 단위로 만들어 줌)
3. 9910 + Math.floor(9991 / 1000) = 9919 (마지막 자리에 원래 수(9991)의 첫째 자리 수를 더해 줌)

=> 9919
```

- R은 오른쪽으로 한 칸씩 이동하는 것

```
ex. 9991
-> 결과: 1999가 나와야 함

1. Math.floor(9991 / 10) = 999 (마지막 자리 수를 뺐을 때 나오는 수)
2. 9991 % 10 = 1 (마지막 자리 수)
3. 1 * 1000 (마지막 자리 수를 1000을 곱하여 천 단위로 만들어 줌)
4. 999 + 1000 = 1999 (1번과 3번을 더하여 첫째자리에 마지막 자리 수가 오도록 함)

=> 1999
```

3. BFS를 돌며, 현재 큐에서 뺀 값이 b와 같을 때까지 반복한다.

- `now`: 큐에서 뺀 값, `next`: DSLR에 따라 계산한 값
- next가 방문하지 않은 수라면
  - 방문 체크 해준다
  - `from[next]` = now
  - `how[next]` = D, S, L, R 중 계산한 명령어 넣기

4. `from`을 추적하며 `how`에 있는 명령어를 모은다.

- `from[b]` -> `from[a]`까지 추적해가면서 `how[b]`의 값을 배열에 푸시한다.
- 푸시한 배열 값을 reverse 한 후 문자열로 엮어 리턴한다.

#### 나의 시행착오

- 단순히 L, R을 4개의 배열로 만들어 푸시와 시프트로 회전시켰다.
- 요즘 알고리즘적으로 시간 단축하며 풀 생각보다는 그냥 "해결" 그 자체에만 급급해하는 것 같다. 알고리즘적 사고를 기르도록 노력하자..
- 다양하게 풀어보려고 노력해야할 필요를 느꼈다.
