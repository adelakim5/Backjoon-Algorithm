## 경비원 (2564)
> 구현 

### 풀이 
1. 동근이가 있는 방향에 따라 다르게 계산한다. 
   
   동근이가
   - 북쪽에 위치하면
   - 남쪽에 위치하면
   - 서쪽에 위치하면
   - 동쪽에 위치하면
  
    에 따라 상점들에 도달하는 최소 거리를 구하는 방법이 달라진다.

    예를 들어, 가로가 `m`, 세로가 `n` 인 좌표에서 동근이의 위치를 `[dx, dy]` , 상점의 위치를 `[sx, sy]` 라고 해보자.

    - 동근이가 현재 북쪽에 위치해 있다면?
    동근 = `[0, dy]`
      1. 북쪽에 있는 상점 = `[0, sy]`
      2. 남쪽에 있는 상점 = `[n, sy]`
      3. 서쪽에 있는 상점 = `[sx, 0]`
      4. 동쪽에 있는 상점 = `[sx, m]`

        북쪽에 있는 상점은 `|dy - sy|` 만큼 떨어져있고, 
        
        남쪽에 있는 상점은 `min(시계방향, 반시계방향)`만큼 떨어져있고, 
        
        서쪽에 있는 상점은 `dy + sx` 만큼 떨어져있고, 
        
        동쪽에 있는 상점은 `m-dy + sx` 만큼 떨어져있다. 

    그러나 이 상점들까지의 거리는 **동근이가 위치한 곳**에 따라 조금씩 계산이 달라진다. 

    - 만약 동근이가 남쪽에 위치해있다면? 
        남쪽에 있는 상점이 `|dy - sy|` 만큼 떨어져있고, 북쪽에 있는 상점이 `min(시계방향, 반시계방향)` 만큼 떨어져있을 것이다. 

    따라서 동근이가 위치할 수 있는 각 방향에 따라 상점까지의 최소 거리를 합산하는 함수를 각각 만들어준다. 

2. 동근이가 있는 방향에 따라 다른 함수를 실행시켜 값을 출력한다. 

[[코딩테스트] 백준 - 경비원 (2564)](https://blog.naver.com/diddnjs02/222133773418)
   