## 트리의 지름

> 1976번  
> DFS

### 풀이

DFS로 가장 먼 노드까지의 거리를 탐색한 후, **해당 노드에서 또 가장 먼 노드까지의 거리**를 탐색한다.

1. Map에 노드의 연결정보를 담는다.

```
  1 => [ { en: 2, c: 3 }, { en: 3, c: 2 } ],
  2 => [ { en: 1, c: 3 }, { en: 4, c: 5 } ],
  3 => [ { en: 1, c: 2 }, { en: 5, c: 11 }, { en: 6, c: 9 } ],
  4 => [ { en: 2, c: 5 }, { en: 7, c: 1 }, { en: 8, c: 7 } ],
  5 => [ { en: 3, c: 11 }, { en: 9, c: 15 }, { en: 10, c: 4 } ],
  6 => [ { en: 3, c: 9 }, { en: 11, c: 6 }, { en: 12, c: 10 } ],
  7 => [ { en: 4, c: 1 } ],
  8 => [ { en: 4, c: 7 } ],
  9 => [ { en: 5, c: 15 } ],
  10 => [ { en: 5, c: 4 } ],
  11 => [ { en: 6, c: 6 } ],
  12 => [ { en: 6, c: 10 } ]
}
```

- en: Map의 key에 해당하는 노드의 자식
- c: 간선의 가중치

2. DFS를 구현한다.

- 1번 노드에서부터 가장 먼 거리에 위치한 노드를 찾는다.

  - 어떤 노드를 선택하든 상관없으나 N이 무조건 1 이상이므로 1번 노드가 반드시 존재하기 때문에 1번 노드를 시작점으로 잡았다.
  - DFS로 탐색하여 가중치의 합산 값이 가장 큰 노드를 찾는다.

- 1번 노드에서부터 **가장 먼 거리에 위치한 노드에서 가장 먼 거리에 위치한 노드**를 찾는다.
  - 1번 노드에서 가장 먼 거리에 위치한 노드는 어쨌든 가장 마지막 자식!
  - 이 노드에서부터 가장 먼 거리에 위치한 노드까지의 거리를 구하면 트리의 지름이 된다.
